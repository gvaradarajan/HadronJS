{"version":3,"sources":["webpack:///webpack/bootstrap 494e0567d3ff045fdd38","webpack:///./engine.js","webpack:///./config_constants.js","webpack:///./vector.js","webpack:///./elastic/movingSphere.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACpCA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA,sBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;;ACxBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;AAIA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 494e0567d3ff045fdd38\n **/","\n\nvar engine = function (options, callback) {\n  var Constants = require('./config_constants.js');\n  var Vector = require('./vector.js');\n  var movingSphere;\n\n  if (Constants.ELASTIC === true) {\n    movingSphere = require('./elastic/movingSphere.js');\n  }\n\n  callback(Constants, Vector, movingSphere);\n\n};\n\n\n// DEMO: A Basic Illustration of How The Engine Can Be Used. Delete the code\n//below and provide your own callback to the engine\n\n\nvar newOptions = {\n  FRICTION_COEFF: 0,\n  ELASTIC: true,\n  WALLS: true,\n  // CONST_MASS: 50,\n  CONST_DENSITY: 0.00025,\n  DIM_X: 750,\n  DIM_Y: 750\n};\n\nengine(newOptions, function (Constants, Vector, movingSphere) {\n  var canvas = document.getElementById('canvas');\n  var c = canvas.getContext('2d');\n  Constants.setConstants(newOptions);\n  var balls = [];\n  while (balls.length < 20) {\n    balls.push(movingSphere.createRandom(balls));\n  }\n  var runSimFrame = function () {\n    c.clearRect(0, 0, canvas.width, canvas.height);\n    var totalKE = 0;\n    var mass = arguments[0].CONST_MASS;\n    balls.forEach(function (ball) {\n      ball.draw(c);\n      totalKE += ball.mass * ball.vel.norm();\n    });\n    totalKE = totalKE / 2;\n    document.getElementById('kE').innerHTML = \"Total KE of System: \" + Math.round(totalKE);\n    var uncheckedBalls = balls.slice();\n    for (var i = 0; i < balls.length; i++) {\n      balls[i].move();\n      uncheckedBalls.shift();\n      for (var j = 0; j < uncheckedBalls.length; j++) {\n        if (balls[i].isCollidedWith(uncheckedBalls[j]) && !balls[i].equals(uncheckedBalls[j])) {\n          balls[i].handleCollision(uncheckedBalls[j]);\n        }\n      }\n    }\n  };\n  var sim = setInterval(runSimFrame.bind(this, Constants), 20);\n  var restart = function () {\n    clearInterval(sim);\n    balls = [];\n    while (balls.length < 20) {\n      balls.push(movingSphere.createRandom(balls));\n    }\n    var friction = parseFloat(document.getElementById(\"friction\").value);\n    Constants.FRICTION_COEFF = friction;\n    sim = setInterval(runSimFrame.bind(this, Constants), 20);\n  };\n  document.getElementById(\"restart\").addEventListener(\"click\", restart);\n});\n\n// module.exports = engine;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./engine.js\n ** module id = 0\n ** module chunks = 0\n **/","var configConstants = {\n  FRICTION_COEFF: 0,\n  ELASTIC: true,\n  GRAVITY: false,\n  CONST_DENSITY: null,\n  CONST_MASS: null,\n  CONST_RADIUS: null,\n  SPACE_DIM: 2,\n  WALLS: true,\n  DIM_X: null,\n  DIM_Y: null\n};\n\n\nconfigConstants.setConstants = function (options) {\n  if (options === undefined) {\n    return;\n  }\n  Object.keys(this).forEach(function (key) {\n    if (options[key] !== undefined) {\n      this[key] = options[key];\n    }\n  }.bind(this));\n};\n\nmodule.exports = configConstants;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./config_constants.js\n ** module id = 1\n ** module chunks = 0\n **/","\nvar Vector = function (x, y) {\n  this[0] = x;\n  this[1] = y;\n};\n\nvar _trunc = function (num) {\n  return parseFloat(num.toFixed(4));\n};\n\n\nVector.prototype.findTheta = function () {\n  if (this[0] === 0) {\n    if (this[1] > 0) {\n      return Math.PI / 2;\n    }\n    else if (this[1] === 0) {\n      return 0;\n    }\n    else {\n      return -Math.PI / 2;\n    }\n  }\n  if (this[1] === 0) {\n    if (this[0] > 0) {\n      return 0;\n    }\n    else {\n      return Math.PI;\n    }\n  }\n  if (this[0] > 0) {\n    return Math.atan(-this[1] / this[0]);\n  }\n  else {\n    return Math.atan(-this[1] / this[0]) + Math.PI;\n  }\n};\n\nVector.prototype.scalarProd = function (vec) {\n  return (this[0] * vec[0]) + (this[1] * vec[1]);\n};\n\nVector.prototype.norm = function () {\n  return Math.pow(this[0], 2) + Math.pow(this[1], 2);\n};\n\nVector.prototype.mag = function () {\n  return Math.sqrt(this.norm());\n};\n\nVector.prototype.getRelativeAngle = function (vec) {\n  if (vec.norm() === 0 || this.norm() === 0) {\n    return null;\n  }\n  var denom = (Math.sqrt(this.norm()) * Math.sqrt(vec.norm()));\n  var innerVal = this.scalarProd(vec) / denom;\n  if (_trunc(innerVal) === 1) {\n    if (this.norm() === vec.norm()) {\n      return 0;\n    }\n    return false;\n  }\n  return Math.acos(_trunc(innerVal));\n};\n\nVector.prototype.unitize = function () {\n  if (this.mag() === 0) {\n    return new Vector(0, 0);\n  }\n  var dir = this.findTheta();\n  var newX = Math.cos(dir);\n  var newY = Math.sin(dir);\n  return new Vector(newX, newY);\n};\n\nVector.prototype.willIntersect = function (otherVec, thisPos, otherPos) {\n  var denom = (this[1] / this[0]) - (otherVec[1] / otherVec[0]);\n  var x = (otherPos[1] - thisPos[1]) +\n          (this[1] / this[0]) * (thisPos[0]) +\n          (otherVec[1] / otherVec[0]) * (otherPos[0]);\n  if (denom === 0) {\n    return true;\n  }\n  x = x / denom;\n  if (x >= 0) {\n    return true;\n  }\n  return false;\n};\n\nVector.prototype.rotate = function (angle) {\n  var newX = this[0] * Math.cos(angle) - this[1] * Math.sin(angle);\n  var newY = this[0] * Math.sin(angle) + this[1] * Math.cos(angle);\n  return new Vector(newX, newY);\n};\n\nmodule.exports = Vector;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./vector.js\n ** module id = 2\n ** module chunks = 0\n **/","\nvar Vector = require('../vector.js');\nvar Constants = require('../config_constants.js');\n\nvar _trunc = function (num) {\n  return parseFloat(num.toFixed(4));\n};\n\nvar movingSphere = function (settings) {\n  this.pos = settings.pos;\n  this.vel = settings.vel;\n  this.mass = settings.mass || Constants.CONST_MASS;\n  this.radius = settings.radius;\n  this.color = settings.color;\n};\n\nmovingSphere.createRandom = function (otherSpheres) {\n  var resultSphere;\n  var creationParams = {};\n  var density = Constants.CONST_DENSITY;\n  var radius = (Math.random() * 15) + 10;\n  var mass = Math.pow(radius, 3) * (4/3) * Math.PI * density;\n  creationParams.color = \"#FF\" + Math.round((Math.random() * 9999));\n  creationParams.pos = [(Constants.DIM_X - 42) * Math.random() + 21,\n                        (Constants.DIM_Y - 42) * Math.random() + 21];\n  creationParams.vel = new Vector(Math.random() * 7, Math.random() * 7);\n  creationParams.radius = radius;\n  creationParams.mass = mass;\n  resultSphere = new movingSphere(creationParams);\n  var invalid = false;\n  for (var i = 0; i < otherSpheres.length; i++) {\n    if (resultSphere.isCollidedWith(otherSpheres[i])) {\n      invalid = true;\n    }\n  }\n  if (invalid) {\n    return movingSphere.createRandom(otherSpheres);\n  }\n  else {\n    return resultSphere;\n  }\n};\n\nmovingSphere.prototype.draw = function (ctx) {\n  ctx.fillStyle = this.color;\n  ctx.beginPath();\n  ctx.arc(this.pos[0], this.pos[1], this.radius, 0, 2 * Math.PI, false);\n  ctx.fill();\n};\n\nmovingSphere.prototype.equals = function (otherObj) {\n  if (this.pos[0] === otherObj.pos[0] && this.pos[1] === otherObj.pos[1]) {\n    return true;\n  }\n  return false;\n};\n\nmovingSphere.prototype.move = function () {\n  var oldVel = Object.assign(Vector, this.vel);\n  this.pos[0] += this.vel[0];\n  this.pos[1] += this.vel[1];\n  if (Constants.WALLS) {\n    this.handleWallCollision();\n  }\n  this.applyFriction();\n  return oldVel;\n};\n\nmovingSphere.prototype.undoMove = function (oldVel) {\n  this.pos[0] -= oldVel[0];\n  this.pos[1] -= oldVel[1];\n};\n\nmovingSphere.prototype.detectWallCollisionX = function () {\n  var Xbound = Constants.DIM_X - this.radius;\n  var dimXRef = this.pos[0] > Xbound || this.pos[0] < 0 + this.radius;\n  return dimXRef;\n};\n\nmovingSphere.prototype.detectWallCollisionY = function () {\n  var Ybound = Constants.DIM_Y - this.radius;\n  var dimYRef = this.pos[1] > Ybound || this.pos[1] < 0 + this.radius;\n  return dimYRef;\n};\n\nmovingSphere.prototype.handleWallCollision = function () {\n  var dimXRef = this.detectWallCollisionX();\n  var dimYRef = this.detectWallCollisionY();\n  if (dimXRef || dimYRef) {\n    this.pos[0] -= this.vel[0];\n    this.pos[1] -= this.vel[1];\n    this.bounce(dimXRef, dimYRef);\n  }\n};\n\nmovingSphere.prototype.applyFriction = function () {\n  coeffFriction = Constants.FRICTION_COEFF;\n  this.vel[0] = this.vel[0] * Math.sqrt(1 - coeffFriction);\n  this.vel[1] = this.vel[1] * Math.sqrt(1 - coeffFriction);\n};\n\nmovingSphere.prototype.bounce = function (bounceX, bounceY) {\n  this.vel[0] = bounceX ? -this.vel[0] : this.vel[0];\n  this.vel[1] = bounceY ? -this.vel[1] : this.vel[1];\n};\n\nmovingSphere.prototype.getCollisionAngle = function (otherObj) {\n  return this.vel.getRelativeAngle(otherObj.vel);\n};\n\nmovingSphere.prototype.isCollidedWith = function (otherObj) {\n  var distance = new Vector(otherObj.pos[0] - this.pos[0], otherObj.pos[1] - this.pos[1]);\n  if (distance.mag() <= (this.radius + otherObj.radius)) {\n    return true;\n  }\n  return false;\n};\n\nmovingSphere.prototype.isStationary = function () {\n  if (this.vel.mag() < 0.07) {\n    return true;\n  }\n  return false;\n};\n\nmovingSphere.prototype.handleStationaryCollision = function (stillObj) {\n  if (!this.isStationary()) {\n    stillObj.vel[0] = this.vel[0];\n    stillObj.vel[1] = this.vel[1];\n    this.vel[0] = 0;\n    this.vel[1] = 0;\n  }\n};\n\n// correctOverlap intended to fix \"sticky balls bug\", needs tweaking\n\nmovingSphere.prototype.correctOverlap = function (otherObj) {\n  var thisUnitVel = this.vel.unitize();\n  var otherUnitVel = otherObj.vel.unitize();\n  var connVec = new Vector(this.pos[0] - otherObj.pos[0],\n                           this.pos[1] - otherObj.pos[1]);\n  while (connVec.mag() <= this.radius + otherObj.radius) {\n    if (!this.detectWallCollisionX() && !this.detectWallCollisionY()) {\n      this.pos[1] -= thisUnitVel[1];\n      this.pos[0] -= thisUnitVel[0];\n      this.pos[0] -= this.vel[0];\n      this.pos[1] -= this.vel[1];\n    }\n    if (!otherObj.detectWallCollisionX() && otherObj.detectWallCollisionY()) {\n      otherObj.pos[0] -= otherObj.vel[0];\n      otherObj.pos[1] -= otherObj.vel[1];\n      otherObj.pos[0] -= otherUnitVel[0];\n      otherObj.pos[1] -= otherUnitVel[1];\n    }\n    connVec[0] = this.pos[0] - otherObj.pos[0];\n    connVec[1] = this.pos[1] - otherObj.pos[1];\n  }\n};\n\nmovingSphere.prototype.kineticEnergy = function () {\n  return this.mass * this.vel.norm() / 2;\n};\n\n\nmovingSphere.prototype.handleCollision = function (otherObj) {\n\n  var formerThisVel = this.vel;\n  var formerOtherVel = otherObj.vel;\n\n  var connVec = new Vector(this.pos[0] - otherObj.pos[0],\n                           this.pos[1] - otherObj.pos[1]);\n  var resultRotation = connVec.findTheta();\n\n  var mass1;\n  var mass2;\n\n  if (Constants.CONST_MASS) {\n    mass1 = Constants.CONST_MASS;\n    mass2 = Constants.CONST_MASS;\n  }\n  else {\n    mass1 = this.mass;\n    mass2 = otherObj.mass;\n  }\n\n  var collAngle = Math.PI;\n\n  var thisVel = this.vel.rotate(resultRotation);\n  var otherVel = otherObj.vel.rotate(resultRotation);\n\n  var angle1 = thisVel.findTheta();\n  var angle2 = otherVel.findTheta();\n\n  var firstTermThis = (thisVel.mag() *\n                       _trunc(Math.cos(angle1-collAngle)) *\n                      (mass1 - mass2) +\n                      (2 * mass2 * otherVel.mag() *\n                       _trunc(Math.cos(angle2-collAngle)))) / (mass1 + mass2);\n\n  this.vel[0] = firstTermThis * _trunc(Math.cos(collAngle));\n  this.vel[0] += thisVel.mag() *\n                 _trunc(Math.sin(angle1 - collAngle)) *\n                 _trunc(Math.cos(collAngle + (Math.PI / 2)));\n\n  this.vel[1] = firstTermThis * _trunc(Math.sin(collAngle));\n  this.vel[1] += thisVel.mag() *\n                 _trunc(Math.sin(angle1 - collAngle)) *\n                 _trunc(Math.sin(collAngle + (Math.PI / 2)));\n\n  var firstTermOther = (otherVel.mag() *\n                       _trunc(Math.cos(angle2-collAngle)) *\n                       (mass2 - mass1) +\n                       (2 * mass1 * thisVel.mag() *\n                       _trunc(Math.cos(angle1-collAngle)))) / (mass1 + mass2);\n\n  otherObj.vel[0] = firstTermOther * _trunc(Math.cos(collAngle));\n  otherObj.vel[0] += otherVel.mag() *\n                     _trunc(Math.sin(angle2 - collAngle)) *\n                     _trunc(Math.cos(collAngle + (Math.PI / 2)));\n\n  otherObj.vel[1] = firstTermOther * _trunc(Math.sin(collAngle));\n  otherObj.vel[1] += otherVel.mag() *\n                     _trunc(Math.sin(angle2 - collAngle)) *\n                     _trunc(Math.sin(collAngle + (Math.PI / 2)));\n\n  otherObj.vel[1] = -otherObj.vel[1];\n  this.vel[1] = -this.vel[1];\n\n  this.vel = this.vel.rotate(-resultRotation);\n  otherObj.vel = otherObj.vel.rotate(-resultRotation);\n\n};\n\n\n\nmodule.exports = movingSphere;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./elastic/movingSphere.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}