{"version":3,"sources":["webpack:///webpack/bootstrap 436538a39f2bbb06e3be","webpack:///./engine.js","webpack:///./config_constants.js","webpack:///./vector.js","webpack:///./elastic/movingSphere.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;ACpCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA,sDAAqD;AACrD,sCAAqC;AACrC;AACA;AACA,uDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;;ACxBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;;;;AAIA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 436538a39f2bbb06e3be\n **/","\n\nvar engine = function (options, callback) {\n  var Constants = require('./config_constants.js');\n  var Vector = require('./vector.js');\n  var movingSphere;\n\n  // this.constants = Constants.setConstants(options);\n  if (Constants.ELASTIC === true) {\n    movingSphere = require('./elastic/movingSphere.js');\n  }\n\n  callback(Constants, Vector, movingSphere);\n\n};\n\nvar newOptions = {\n  FRICTION_COEFF: 0.0094,\n  ELASTIC: true,\n  WALLS: true,\n  CONST_MASS: 50,\n  DIM_X: 750,\n  DIM_Y: 750\n};\n\n// FRICTION_COEFF: 0.0054;\n\nengine(newOptions, function (Constants, Vector, movingSphere) {\n  var canvas = document.getElementById('canvas');\n  var c = canvas.getContext('2d');\n  Constants.setConstants(newOptions);\n  // var vel1 = new Vector(0,3);\n  // var vel2 = new Vector(0,-3);\n  //\n  // var newObj = new movingSphere({pos: [500, 40],\n  //                                vel: vel1,\n  //                                radius: 20,\n  //                                color: \"#00FF00\"});\n  // var newObj2 = new movingSphere({pos: [510, 600],\n  //                                 vel: vel2,\n  //                                 radius: 20,\n  //                                 color: \"#FF0000\"});\n  var balls = [];\n  // debugger\n  while (balls.length < 11) {\n    balls.push(movingSphere.createRandom(balls));\n  }\n  setInterval(function () {\n    c.clearRect(0, 0, canvas.width, canvas.height);\n    // newObj.draw(c);\n    // newObj2.draw(c);\n    balls.forEach(function (ball) {\n      ball.draw(c);\n    });\n    var checkedBalls = balls.slice();\n    for (var i = 0; i < balls.length; i++) {\n      checkedBalls.shift();\n      balls[i].move(checkedBalls);\n    }\n    // newObj.move([newObj2]);\n    // newObj2.move([]);\n  }, 20);\n});\n\n// module.exports = engine;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./engine.js\n ** module id = 0\n ** module chunks = 0\n **/","var configConstants = {\n  FRICTION_COEFF: 0,\n  ELASTIC: true,\n  GRAVITY: false,\n  CONST_DENSITY: null,\n  CONST_MASS: null,\n  CONST_RADIUS: null,\n  SPACE_DIM: 2,\n  WALLS: true,\n  DIM_X: null,\n  DIM_Y: null\n};\n\n\nconfigConstants.setConstants = function (options) {\n  if (options === undefined) {\n    return;\n  }\n  Object.keys(this).forEach(function (key) {\n    if (options[key] !== undefined) {\n      this[key] = options[key];\n    }\n  }.bind(this));\n};\n\nmodule.exports = configConstants;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./config_constants.js\n ** module id = 1\n ** module chunks = 0\n **/","\nvar Vector = function (x, y) {\n  this[0] = x;\n  this[1] = y;\n};\n\nvar _trunc = function (num) {\n  return parseFloat(num.toFixed(4));\n};\n\n\nVector.prototype.findTheta = function () {\n  if (this[0] === 0) {\n    if (this[1] > 0) {\n      return Math.PI / 2;\n    }\n    else {\n      return -Math.PI / 2;\n    }\n  }\n  if (this[1] === 0) {\n    if (this[0] > 0) {\n      return 0;\n    }\n    else {\n      return Math.PI;\n    }\n  }\n  if (this[0] > 0) {\n    return Math.atan(-this[1] / this[0]);\n  }\n  else {\n    return Math.atan(-this[1] / this[0]) + Math.PI;\n  }\n};\n\nVector.prototype.scalarProd = function (vec) {\n  return (this[0] * vec[0]) + (this[1] * vec[1]);\n};\n\nVector.prototype.norm = function () {\n  return Math.pow(this[0], 2) + Math.pow(this[1], 2);\n};\n\nVector.prototype.mag = function () {\n  return Math.sqrt(this.norm());\n};\n\nVector.prototype.getRelativeAngle = function (vec) {\n  if (vec.norm() === 0 || this.norm() === 0) {\n    return null;\n  }\n  var denom = (Math.sqrt(this.norm()) * Math.sqrt(vec.norm()));\n  var innerVal = this.scalarProd(vec) / denom;\n  if (_trunc(innerVal) === 1) {\n    if (this.norm() === vec.norm()) {\n      return 0;\n    }\n    return false;\n  }\n  return Math.acos(_trunc(innerVal));\n};\n\nVector.prototype.rotate = function (angle) {\n  var newX = this[0] * Math.cos(angle) - this[1] * Math.sin(angle);\n  var newY = this[0] * Math.sin(angle) + this[1] * Math.cos(angle);\n  return new Vector(newX, newY);\n};\n\nmodule.exports = Vector;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./vector.js\n ** module id = 2\n ** module chunks = 0\n **/","\nvar Vector = require('../vector.js');\nvar Constants = require('../config_constants.js');\n\nvar _trunc = function (num) {\n  return parseFloat(num.toFixed(4));\n};\n\nvar movingSphere = function (settings) {\n  this.pos = settings.pos;\n  this.vel = settings.vel;\n  this.radius = settings.radius;\n  this.color = settings.color;\n};\n\nmovingSphere.createRandom = function (otherSpheres) {\n  var resultSphere;\n  var creationParams = {};\n  creationParams.color = \"#FF0000\";\n  creationParams.pos = [(Constants.DIM_X - 42) * Math.random() + 21,\n                        (Constants.DIM_Y - 42) * Math.random() + 21];\n  creationParams.vel = new Vector(Math.random() * 8, Math.random() * 8);\n  creationParams.radius = 20;\n  resultSphere = new movingSphere(creationParams);\n  var invalid = false;\n  for (var i = 0; i < otherSpheres.length; i++) {\n    if (resultSphere.isCollidedWith(otherSpheres[i])) {\n      invalid = true;\n    }\n  }\n  if (invalid) {\n    return movingSphere.createRandom(otherSpheres);\n  }\n  else {\n    return resultSphere;\n  }\n};\n\nmovingSphere.prototype.draw = function (ctx) {\n  ctx.fillStyle = this.color;\n  ctx.beginPath();\n  ctx.arc(this.pos[0], this.pos[1], this.radius, 0, 2 * Math.PI, false);\n  ctx.fill();\n};\n\nmovingSphere.prototype.equals = function (otherObj) {\n  if (this.pos[0] === otherObj.pos[0] && this.pos[1] === otherObj.pos[1]) {\n    return true;\n  }\n  return false;\n};\n\nmovingSphere.prototype.move = function (otherObjs) {\n  var that = this;\n  // debugger\n  otherObjs.forEach(function (obj) {\n    if (that.isCollidedWith(obj) && !that.equals(obj)) {\n      that.handleCollision(obj);\n    }\n  });\n  this.pos[0] += this.vel[0];\n  this.pos[1] += this.vel[1];\n  // debugger\n  if (Constants.WALLS) {\n    this.detectWallCollision();\n  }\n  this.applyFriction();\n};\n\nmovingSphere.prototype.detectWallCollision = function () {\n  var Ybound = Constants.DIM_Y - this.radius;\n  var Xbound = Constants.DIM_X - this.radius;\n  var dimXRef = this.pos[0] > Xbound || this.pos[0] < 0 + this.radius;\n  var dimYRef = this.pos[1] > Ybound || this.pos[1] < 0 + this.radius;\n  if (dimXRef || dimYRef) {\n    // debugger\n    this.pos[0] -= this.vel[0];\n    this.pos[1] -= this.vel[1];\n    this.bounce(dimXRef, dimYRef);\n  }\n};\n\nmovingSphere.prototype.applyFriction = function () {\n  coeffFriction = Constants.FRICTION_COEFF;\n  this.vel[0] = this.vel[0] * Math.sqrt(1 - coeffFriction);\n  this.vel[1] = this.vel[1] * Math.sqrt(1 - coeffFriction);\n};\n\nmovingSphere.prototype.bounce = function (bounceX, bounceY) {\n  this.vel[0] = bounceX ? -this.vel[0] : this.vel[0];\n  this.vel[1] = bounceY ? -this.vel[1] : this.vel[1];\n};\n\nmovingSphere.prototype.getCollisionAngle = function (otherObj) {\n  return this.vel.getRelativeAngle(otherObj.vel);\n};\n\nmovingSphere.prototype.isCollidedWith = function (otherObj) {\n  var distance = new Vector(otherObj.pos[0] - this.pos[0], otherObj.pos[1] - this.pos[1]);\n  if (distance.mag() <= (this.radius + otherObj.radius)) {\n    return true;\n  }\n  return false;\n};\n\nmovingSphere.prototype.isStationary = function () {\n  if (this.vel.mag() < 0.07) {\n    return true;\n  }\n  return false;\n};\n\nmovingSphere.prototype.handleStationaryCollision = function (stillObj) {\n  if (!this.isStationary()) {\n    stillObj.vel[0] = this.vel[0];\n    stillObj.vel[1] = this.vel[1];\n    this.vel[0] = 0;\n    this.vel[1] = 0;\n  }\n};\n\nmovingSphere.prototype.handleCollision = function (otherObj) {\n  var connVec = new Vector(this.pos[0] - otherObj.pos[0],\n                           this.pos[1] - otherObj.pos[1]);\n  var resultRotation = connVec.findTheta();\n\n  var mass1;\n  var mass2;\n\n  if (Constants.CONST_MASS) {\n    mass1 = Constants.CONST_MASS;\n    mass2 = Constants.CONST_MASS;\n  }\n  else {\n    mass1 = this.mass;\n    mass2 = otherObj.mass;\n  }\n\n  var collAngle = Math.PI;\n\n  var thisVel = this.vel.rotate(resultRotation);\n  var otherVel = otherObj.vel.rotate(resultRotation);\n\n\n  var angle1 = thisVel.findTheta();\n  var angle2 = otherVel.findTheta();\n  // debugger\n\n  this.vel[0] = thisVel.mag() *\n                _trunc(Math.cos(angle1-collAngle)) *\n                (mass1 - mass2);\n\n  this.vel[0] += 2 * mass2 * otherVel.mag() *\n                 _trunc(Math.cos(angle2-collAngle));\n\n  this.vel[1] = thisVel.mag() *\n                _trunc(Math.cos(angle1-collAngle)) *\n                (mass1 - mass2);\n\n  this.vel[1] += 2 * mass2 * otherVel.mag() *\n                 _trunc(Math.cos(angle2-collAngle));\n\n  this.vel[0] = _trunc(this.vel[0] / (mass1 + mass2)) * _trunc(Math.cos(collAngle));\n  this.vel[0] += thisVel.mag() *\n                 _trunc(Math.sin(angle1 - collAngle)) *\n                 _trunc(Math.cos(collAngle + (Math.PI / 2)));\n\n  this.vel[1] = _trunc(this.vel[1] / (mass1 + mass2)) * _trunc(Math.sin(collAngle));\n  this.vel[1] += thisVel.mag() *\n                 _trunc(Math.sin(angle1 - collAngle)) *\n                 _trunc(Math.sin(collAngle + (Math.PI / 2)));\n\n  otherObj.vel[0] = otherVel.mag() *\n                _trunc(Math.cos(angle2-collAngle)) *\n                (mass1 - mass2);\n\n  otherObj.vel[0] += 2 * mass2 * thisVel.mag() *\n                 _trunc(Math.cos(angle1-collAngle));\n\n  otherObj.vel[1] = otherVel.mag() *\n                _trunc(Math.cos(angle2-collAngle)) *\n                (mass1 - mass2);\n\n  otherObj.vel[1] += 2 * mass2 * thisVel.mag() *\n                 _trunc(Math.cos(angle1-collAngle));\n\n  otherObj.vel[0] = _trunc(otherObj.vel[0] / (mass1 + mass2)) * _trunc(Math.cos(collAngle));\n  otherObj.vel[0] += otherVel.mag() *\n                     _trunc(Math.sin(angle2 - collAngle)) *\n                     _trunc(Math.cos(collAngle + (Math.PI / 2)));\n\n  otherObj.vel[1] = _trunc(otherObj.vel[1] / (mass1 + mass2)) * _trunc(Math.sin(collAngle));\n  otherObj.vel[1] += otherVel.mag() *\n                     _trunc(Math.sin(angle2 - collAngle)) *\n                     _trunc(Math.sin(collAngle + (Math.PI / 2)));\n\n  otherObj.vel[1] = -otherObj.vel[1];\n  this.vel[1] = -this.vel[1];\n\n  this.vel = this.vel.rotate(-resultRotation);\n  otherObj.vel = otherObj.vel.rotate(-resultRotation);\n\n\n\n};\n\n\n\nmodule.exports = movingSphere;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./elastic/movingSphere.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}